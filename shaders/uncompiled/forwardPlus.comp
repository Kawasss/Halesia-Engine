#version 460
#define MAX_LIGHT_INDICES 7

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Cell
{
	float lightCount;
	float lightIndices[MAX_LIGHT_INDICES]; // this uses floats because the padding for ints is messed up
};

layout (std430, set = 0, binding = 0) buffer Cells
{
	uint depth;
	uint width;
	uint height;
	Cell data[];
} cells;

layout (set = 0, binding = 1) readonly buffer Lights
{
	vec3 position[];
} lights;

layout (set = 0, binding = 2) uniform Matrices
{
	mat4 proj;
	mat4 view;
} matrices;

float GetLinearizedDepth(float depth)
{
    return (2 * 0.01f * 1000.0f) / (1000.0f - depth * (1000.0f - 0.01f)) / 1000.0f;
}

vec3 GetScreenSpace(vec3 pos)
{
	vec4 screenSpace = matrices.proj * matrices.view * vec4(pos, 1);
	screenSpace.xy = (screenSpace.xy / screenSpace.w + 1) * 0.5f;
	screenSpace.z = GetLinearizedDepth(screenSpace.z);

	return screenSpace.xyz;
}

vec3 ConvertScreenSpaceToCellSpace(vec3 screenSpace)
{
	return screenSpace * vec3(cells.width, cells.height, cells.depth);
}

uint GetCellIndex(vec3 cellSpace)
{
	uint sliceSize = cells.width * cells.height;

	uint zIndex = uint(cellSpace.z * sliceSize);
	uint cellIndex = uint(cells.height * floor(cellSpace.x) + cellSpace.y);
	return zIndex + cellIndex;
}

void main()
{
	vec3 pos = lights.position[gl_GlobalInvocationID.x];
	vec3 screenSpace = GetScreenSpace(pos);

	if (screenSpace.x > 1.0f || screenSpace.x < 0.0f || screenSpace.y > 1.0f || screenSpace.y < 0.0f)
		return;

	vec3 cellSpace = ConvertScreenSpaceToCellSpace(screenSpace);

	uint index = GetCellIndex(cellSpace);

	cells.data[index].lightIndices[uint(cells.data[index].lightCount++)] = float(gl_GlobalInvocationID.x);
}