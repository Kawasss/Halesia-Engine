#version 460
#extension GL_EXT_ray_tracing : require

#define PI 3.14159265359
#define TWO_PI (PI * 2)
#define ONE_OVER_PI (1 / PI)

#define SAMPLE_COUNT 1

layout(location = 0) rayPayloadEXT Payload {
	vec3 origin;
	vec3 direction;
	vec3 color;

	int isActive;
} payload;

layout(push_constant) uniform Camera
{
	vec4 position;

	mat4 viewInv;
	mat4 projInv;

	float random;
} camera;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba8) uniform image2D globalIlluminationImage;
layout(binding = 2, set = 0) uniform sampler2D albedoImage;
layout(binding = 3, set = 0) uniform sampler2D normalImage;
layout(binding = 4, set = 0) uniform sampler2D positionImage;

vec3 CosineSampleHemisphereLocal(vec2 random) // https://github.com/boksajak/brdf/blob/master/brdf.h
{
	float a = sqrt(random.x);
	float b = TWO_PI * random.y;

	vec3 ret = vec3(a * cos(b), a * sin(b), sqrt(1.0 - random.x));

	return ret;
}

mat3 GetBasisFromVector(vec3 normal) // https://columbusutrigas.com/posts/rtgi/
{
	vec3 up = abs(normal.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0);

	vec3 x = normalize(cross(up, normal));
	vec3 y = cross(normal, x);
	vec3 z = normal;

	return mat3(x, y, z);
}

vec3 CosineSampleHemisphere(vec2 random, vec3 normal)
{
	vec3 local = CosineSampleHemisphereLocal(random);
	mat3 trans = GetBasisFromVector(normal);

	return trans * local;
}

vec3 CosineSampleHemisphereNew(vec2 random, vec3 normal) // https://www.shadertoy.com/view/fdS3zw
{
    float r = sqrt(random.x);
    float theta = TWO_PI * random.y;
 
    vec3 B = normalize(cross(normal, vec3(0.0,1.0,1.0)));
	vec3 T = cross(B, normal);
    
    return normalize(r * sin(theta) * B + sqrt(1.0 - random.x) * normal + r * cos(theta) * T);
}

vec3 UniformSampleHemisphere(vec2 random, vec3 normal)
{
    float r = sqrt(1.0 - random.x * random.x);
    float phi = TWO_PI * random.y;
    
    vec3  B = normalize(cross(normal, vec3(0.0,1.0,1.0)));
	vec3  T = cross(B, normal);
    
    return normalize(r * sin(phi) * B + random.x * normal + r * cos(phi) * T);
}

void main()
{
	vec2 relCoors = vec2(gl_LaunchIDEXT.xy) / vec2(gl_LaunchSizeEXT.xy);

	vec3 normal = texture(normalImage, relCoors).xyz;
	vec3 position = texture(positionImage, relCoors).xyz;

    vec2 uv = relCoors * 2.0 - 1.0;

    vec4 target = camera.projInv * vec4(uv.x, uv.y, 1, 1);
	vec3 cameraDir = (camera.viewInv * vec4(normalize(target.xyz), 0)).xyz;

	payload.color = vec3(0);

	for (int i = 0; i < SAMPLE_COUNT; i++)
	{
		payload.isActive = 1;
		float random = float(i) / float(SAMPLE_COUNT);

		if (normal == vec3(0)) // shoot the ray at the skybox (maybe sample in this shader instead of the rmiss shader ??)
		{
			payload.origin = camera.position.xyz;
			payload.direction = cameraDir;
		}
		else
		{
			payload.origin = position;
			payload.direction = UniformSampleHemisphere(vec2(random), normal); // vec2(1) should be a random uniform number
		}

		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, payload.origin, 0.01, payload.direction, 1000.0, 0);
	}

	vec3 result = payload.color / float(SAMPLE_COUNT);

	imageStore(globalIlluminationImage, ivec2(gl_LaunchIDEXT.xy), vec4(result, 1));
}